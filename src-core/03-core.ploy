# Copyright 2014 George King.
# Permission to use this file is granted in ploy/license.txt.

# builtin macros and functions that are available to all programs.


<pub-fn error [-msg]
  # raise an error. for now we can only print the message and exit.
  (_host-write (field std-err 1) 'error: ')
  (_host-write (field std-err 1) msg)
  (_host-write (field std-err 1) '\n')
  (exit 1)>

<macro check [-condition -msg]
  ~<if (not ,condition) (error ,msg)>>

# math functions.

<pub-fn iinc [-i] (iadd i 1)>

<pub-fn idec [-i] (isub i 1)>

# type functions.

<pub-fn is-ptr  [-o] (is (type-of o) Ptr)>
<pub-fn is-int  [-o] (is (type-of o) Int)>
<pub-fn is-sym  [-o] (is (type-of o) Sym)>
<pub-fn is-data [-o] (is (type-of o) Data)>
<pub-fn is-env  [-o] (is (type-of o) Env)>
<pub-fn is-type [-o] (is (type-of o) Type)>

# arr functions.

<pub-fn hd [-arr] (el arr 0)>

<pub-fn tl [-arr] (el arr (idec (mlen arr)))>

<pub-fn arr-next [-arr]
  # this a poor substitute for a real Stream iterator.
 (slice arr 1 (mlen arr))>

<pub-fn arr-from [-arr -from]
  (slice arr from (mlen arr))>

<pub-fn arr-to [-arr -to]
  (slice arr 0 to)>

# control flow.

<macro _if-then [-pred -then]
  # 'if' variant that takes exactly two expressions; for bootstrapping the 'if' macro.
  {:If pred then void}>

<macro _if-then-else [-pred -then -else]
  # 'if' variant that takes exactly three expressions; for bootstrapping the 'if' macro.
  {:If pred then else}>

<macro if [&exprs]
  # generic 'if'. inspired by paul graham's arc-lisp.
  <_if-then (ilt (mlen exprs) 2) (error "degenerate if form")>
  <let-fn f [-pred -then -rest]
    <let l (mlen rest)>
    #(_errR1L 'f l: ' l)
    #(_errR1L 'f pred: ' pred)
    #(_errR1L 'f then: ' then)
    #(_errR1L 'f rest: ' rest)
    <_if-then-else (not l)
      {:If pred then void} # final if-else
      <_if-then-else (ieq l 1)
        {:If pred then (hd rest)} # final clause is an unconditional else.
        {:If pred then (self (hd rest) (el rest 1) (arr-from rest 2))}>>>
  (f (hd exprs) (el exprs 1) (slice exprs 2 (mlen exprs)))>

<macro when [-pred &body]
  # if 'pred', do 'exprs'. else none.
  {:If pred {:Do body} void}> # TODO: eventually this should use splice-unquote.

# output functions.

<let-fn write1 [-file -str]
  # write a single string.
  # TODO: support other types.
  (_host-write (field file 1) str)>

<let-fn writeR1 [-file -obj]
  # write a single repr.
  (_host-write-repr (field file 1) obj)>

# TODO: this is a temporary, halfway solution to the desired printing functions.
# would be better to use a macro to generate each function with no subcalls.

<pub-fn writeSE [-file -sep -end -first -rest]
  # write strings with separator and end strings.
  #(_errR1L 'writeSE f: ' first)
  #(_errR1L 'writeSE r: ' rest)
  (write1 file first)
  <if (not rest)
    (write1 file end)
    <do
      (write1 file sep)
      (self file sep end (hd rest) (arr-next rest))>>>

<pub-fn writeRSE [-file -sep -end -first -rest]
  # write reprs with separator and end strings.
  (writeR1 file first)
  <if (not rest)
    (write1 file end)
    <do
      (write1 file sep)
      (self file sep end (hd rest) (arr-next rest))>>>

<pub-fn out [&objs]
  <if (not objs)
    void
    (writeSE std-out '' '' (hd objs) (arr-next objs))>>

<pub-fn outS [&objs]
  <if (not objs)
    void
    (writeSE std-out ' ' '' (hd objs) (arr-next objs))>>

<pub-fn outL [&objs]
  <if (not objs)
    (write1 std-out '\n')
    (writeSE std-out '' '\n' (hd objs) (arr-next objs))>>

<pub-fn outSL [&objs]
  <if (not objs)
    (write1 std-out '\n')
    (writeSE std-out ' ' '\n' (hd objs) (arr-next objs))>>

<pub-fn outSS [&objs]
  <if (not objs)
    (write1 std-out ' ')
    (writeSE std-out ' ' ' ' (hd objs) (arr-next objs))>>

<pub-fn outLL [&objs]
  <if (not objs)
    (write1 std-out '\n')
    (writeSE std-out '\n' '\n' (hd objs) (arr-next objs))>>


<pub-fn err [&objs]
  <if (not objs)
    void
    (writeSE std-err '' '' (hd objs) (arr-next objs))>>

<pub-fn errS [&objs]
  <if (not objs)
    void
    (writeSE std-err ' ' '' (hd objs) (arr-next objs))>>

<pub-fn errL [&objs]
  <if (not objs)
    (write1 std-err '\n')
    (writeSE std-err '' '\n' (hd objs) (arr-next objs))>>

<pub-fn errSS [&objs]
  <if (not objs)
    (write1 std-err ' ')
    (writeSE std-err ' ' ' ' (hd objs) (arr-next objs))>>

<pub-fn errSL [&objs]
  <if (not objs)
    (write1 std-err '\n')
    (writeSE std-err ' ' '\n' (hd objs) (arr-next objs))>>

<pub-fn errLL [&objs]
  <if (not objs)
    (write1 std-err '\n')
    (writeSE std-err '\n' '\n' (hd objs) (arr-next objs))>>


<pub-fn outR [&objs]
  <if (not objs)
    void
    (writeSE std-out '' '' (hd objs) (arr-next objs))>>

<pub-fn outRS [&objs]
  <if (not objs)
    void
    (writeSE std-out ' ' '' (hd objs) (arr-next objs))>>

<pub-fn outRL [&objs]
  <if (not objs)
    (write1 std-out '\n')
    (writeRSE std-out '' '\n' (hd objs) (arr-next objs))>>

<pub-fn outRSS [&objs]
  <if (not objs)
    (write1 std-out ' ')
    (writeRSE std-out ' ' ' ' (hd objs) (arr-next objs))>>

<pub-fn outRSL [&objs]
  <if (not objs)
    (write1 std-out '\n')
    (writeRSE std-out ' ' '\n' (hd objs) (arr-next objs))>>

<pub-fn outRLL [&objs]
  <if (not objs)
    (write1 std-out '\n')
    (writeRSE std-out '\n' '\n' (hd objs) (arr-next objs))>>


<pub-fn errR [&objs]
  <if (not objs)
    void
    (writeRSE std-err '' '' (hd objs) (arr-next objs))>>

<pub-fn errRS [&objs]
  <if (not objs)
    void
    (writeRSE std-err ' ' '' (hd objs) (arr-next objs))>>

<pub-fn errRL [&objs]
  <if (not objs)
    (write1 std-err '\n')
    (writeRSE std-err '' '\n' (hd objs) (arr-next objs))>>

<pub-fn errRSS [&objs]
  <if (not objs)
    (write1 std-err ' ')
    (writeRSE std-err ' ' ' ' (hd objs) (arr-next objs))>>

<pub-fn errRSL [&objs]
  <if (not objs)
    (write1 std-err '\n')
    (writeRSE std-err ' ' '\n' (hd objs) (arr-next objs))>>

<pub-fn errRLL [&objs]
  <if (not objs)
    (write1 std-err '\n')
    (writeRSE std-err '\n' '\n' (hd objs) (arr-next objs))>>
