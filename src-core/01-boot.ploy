# Copyright 2014 George King.
# Permission to use this file is granted in ploy/license.txt.

# macros and functions that must be bootstrapped using special syntax,
# before the idiomatic form macros are defined.
# once available, the form macros are used;
# they provide a layer of abstraction between ploy code and the exact evaluation semantics.

(RUN # special call form to run the argument as code in the current environment.
  # the 'macro' macro defines a new macro in the current environment.
  # because we cannot use macro to define itself, we must define it using raw forms.
  # note the structural similarity between the outer Fn form and the inner struct literal.
  {:Bind
    false # is-mutable.
    true # is-public.
    `macro # symbol to bind.
    {:Fn # Fn creates both functions and macros.
      true # is-native.
      true # is-macro.
      `[-sym -pars &body] # the parameter list, which does not get evaluated.
      nil # ret-type.
      `{:Bind # the body of the 'macro' macro is a Bind form.
        false # is-mutable.
        true # is-public.
        sym # the sym parameter that the macro to be created is bound to (not `macro).
        {:Fn # the value of the binding is created by evaluating the FN form;
          # note that this inner FN is inside a vec literal;
          # when the 'macro' macro is expanded, the literal is evaluated,
          # and a {FN ...} form is the resulting code vector.
          true # is-native.
          true # is-macro.
          pars
          nil # ret-type.
          {:Do *body}}}}})

# define macros to wrap the special forms.

<macro fn [-pars &body]
  # create a function.
  {:Fn
    true # is-native.
    false # is-macro.
    pars
    nil # ret-type.
    {:Do *body}}>

<macro quo [-expr]
  # absolute quotation of an expression.
  # evaluating a QUO form simply yields the contained expression, unevaluated.
  {:Quo expr}>

<macro qua [-expr]
  # quasiquotation of an expression.
  # this is similar to quo, except that subexpressions can be unquoted,
  # in which case they are evaluated.
  # QUA forms themselves do not evaluate; they are converted by the preprocessor.
  # equivalent to `expr syntax.
  # TODO: implement quasiquotation as a macro instead of in the preprocessor?
  {:Qua expr}>

<macro unq [-expr]
  # unquotation of an expression.
  # this form indicates that the unquoted subexpression should be evaluated within a qua form.
  # this for does not evaluate, and therefore must be inside of a qua,
  # where it will get transformed appropriately.
  # equivalent to ,expr syntax
  {:Unq expr}>

<macro do [&body]
  {:Do *body}>

<macro scope [&body]
  {:Scope {:Do *body}}>

<macro let [-sym -expr]
  # immutable, private binding.
  {:Bind false false sym expr}>

<macro var [-sym -expr]
  # mutable, private binding.
  {:Bind true false sym expr}>

<macro pub [-sym -expr]
  # immutable, public binding.
  {:Bind false true sym expr}>

# additional bootstrap macros.

<macro let-fn [-sym -pars &body]
  ~<let ,sym <fn ,pars ,*body>>>

<macro pub-fn [-sym -pars &body]
  ~<pub ,sym <fn ,pars ,*body>>>
