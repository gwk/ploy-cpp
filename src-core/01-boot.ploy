# Copyright 2014 George King.
# Permission to use this file is granted in ploy/license.txt.

# macros and functions that must be bootstrapped using special syntax.
# the !{:...} idiom is used to construct and run special forms directly,
# before the idiomatic form macros are defined.
# once available, the form macros should be used instead of this idiom;
# they provide a layer of abstraction between ploy code and the exact evaluation semantics.

!{:Let `macro
  # the 'macro' macro defines a new macro in the current environment.
  # because we cannot use macro to define itself, we must define it using raw forms.
  # note the structural similarity between the outer Fn form and the inner struct literal.
  {:Fn # Fn creates both functions and macros.
    `macro # the sym for this macro is `macro.
    true # is-native.
    true # is-macro.
    `[-sym -pars &body] # the parameter list, which does not get evaluated.
    nil # ret.
    `{:Let # the body of the 'macro' macro is a Let form.
      sym # the sym parameter that the macro to be created is bound to (not `macro).
      {:Fn # the value of the binding is created by evaluating the FN form;
        # note that this inner FN is inside a vec literal;
        # when the 'macro' macro is expanded, the literal is evaluated,
        # and a {FN ...} form is the resulting code vector.
        sym
        true
        true
        pars
        nil # unspecified ret type.
        (_boot-mk-do body)}}}}

# define macros to wrap the special forms.

<macro fna [-pars &body]
  # the 'fna' macro defines an anonymous function.
  {:Fn
    `anon
    true
    false
    pars
    nil # unspecified ret type.
    (_boot-mk-do body)}>

<macro fn [-sym -pars &body]
  # the 'fn' macro defines a function in the current environment.
  {:Let
    sym
    {:Fn
      sym
      true
      false
      pars
      nil # unspecified ret type.
      (_boot-mk-do body)}}>

<macro quo [-expr]
  # absolute quotation of an expression.
  # evaluating a QUO form simply yields the contained expression, unevaluated.
  {:Quo expr}>

<macro qua [-expr]
  # quasiquotation of an expression.
  # this is similar to quo, except that subexpressions can be unquoted,
  # in which case they are evaluated.
  # QUA forms themselves do not evaluate; they are converted by the preprocessor.
  # equivalent to `expr syntax.
  # TODO: implement quasiquotation as a macro instead of in the preprocessor?
  {:Qua expr}>

<macro unq [-expr]
  # unquotation of an expression.
  # this form indicates that the unquoted subexpression should be evaluated within a qua form.
  # this for does not evaluate, and therefore must be inside of a qua,
  # where it will get transformed appropriately.
  # equivalent to ,expr syntax
  {:Unq expr}>

<macro do [&exprs]
  (_boot-mk-do exprs)>

<macro scope [&exprs]
  {:Scope (_boot-mk-do exprs)}>

<macro let [-sym -expr]
  # bind the value of expr to sym in the current environment.
  {:Let sym expr}>
