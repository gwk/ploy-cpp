# Copyright 2014 George King.
# Permission to use this file is granted in ploy/license.txt.

# bootstrap ploy, beginning with macros for the special forms.
# this module defines initial versions of many core constructs;
# some are imported into core, and others are replaced with more capable implementations.

(RUN # special call form to run the argument as code in the current environment.
  # the 'macro' macro defines a new macro in the current environment.
  # because we cannot use macro to define itself, we must define it using raw forms.
  # note the structural similarity between the outer Fn form and the inner struct literal.
  (CONS Bind
    false # is-mutable.
    true # is-public.
    `macro # name.
    (CONS Fn # Fn creates both functions and macros.
      true # is-native.
      true # is-macro.
      `[-sym -pars &body] # the parameter list, which does not get evaluated.
      nil # ret-type.
      `(CONS Bind # the body of the 'macro' macro is a Bind form.
        false # is-mutable.
        true # is-public.
        sym # name.
        (CONS Fn # the value of the binding is created by evaluating the Fn form.
          true # is-native.
          true # is-macro.
          pars
          nil # ret-type.
          (CONS Do (CONS Arr-Expr *body)))))))

# define macros to wrap the special forms.

<macro fn [-pars &body]
  # create a function.
  (CONS Fn
    true # is-native.
    false # is-macro.
    pars
    nil # ret-type.
    (CONS Do (CONS Arr-Expr *body)))>

<macro quo [-expr]
  # absolute quotation of an expression.
  # evaluating a QUO form simply yields the contained expression, unevaluated.
  (CONS Quo expr)>

<macro qua [-expr]
  # quasiquotation of an expression.
  # this is similar to quo, except that subexpressions can be unquoted,
  # in which case they are evaluated.
  # QUA forms themselves do not evaluate; they are converted by the preprocessor.
  # equivalent to `expr syntax.
  # TODO: implement quasiquotation as a macro instead of in the preprocessor?
  (CONS Qua expr)>

<macro unq [-expr]
  # unquotation of an expression.
  # this form indicates that the unquoted subexpression should be evaluated within a qua form.
  # this for does not evaluate, and therefore must be inside of a qua,
  # where it will get transformed appropriately.
  # equivalent to ,expr syntax
  (CONS Unq expr)>

<macro do [&body]
  (CONS Do (CONS Arr-Expr *body))>

<macro scope [&body]
  (CONS Scope (CONS Do (CONS Arr-Expr *body)))>

<macro let [-sym -expr]
  # immutable, private binding.
  (CONS Bind false false sym expr)>

<macro var [-sym -expr]
  # mutable, private binding.
  (CONS Bind true false sym expr)>

<macro pub [-sym -expr]
  # immutable, public binding.
  (CONS Bind false true sym expr)>

# the raw forms are now available through macros.

<macro let-fn [-sym -pars &body]
  ~<let ,sym <fn ,pars <let ,sym self> ,*body>>>

<macro pub-fn [-sym -pars &body]
  ~<pub ,sym <fn ,pars <let ,sym self> ,*body>>>

<let alen cmpd-len> # for now use a simple alias.

# math functions.

<pub-fn iinc [-i] (iadd i 1)>

<pub-fn idec [-i] (isub i 1)>

# type functions.

<pub-fn is-ptr  [-o] (is (type-of o) Ptr)>
<pub-fn is-int  [-o] (is (type-of o) Int)>
<pub-fn is-sym  [-o] (is (type-of o) Sym)>
<pub-fn is-data [-o] (is (type-of o) Data)>
<pub-fn is-env  [-o] (is (type-of o) Env)>
<pub-fn is-type [-o] (is (type-of o) Type)>

# control flow.

<pub-fn error [-msg]
  # raise an error. for now we can only print the message and exit.
  (raise msg)>

<macro recur [-pars &body]
  ~(<fn ,pars ,*body>)>

<macro _if [-pred -then -else]
  # bootstrap 'if' that takes exactly three expressions.
  (CONS If pred then else)>

<macro if [&exprs]
  # generic 'if'. inspired by paul graham's arc-lisp.
  <let len (alen exprs)>
  <_if (ilt len 2) (error "degenerate if form")
    <recur [-i=0]
      <let pred (ael exprs i)>
      <let then (ael exprs (iinc i))>
      <_if (ieq (iadd i 2) len)
        (CONS If pred then void) # final if-else.
        <_if (ieq (iadd i 3) len)
          (CONS If pred then (ael exprs (iadd i 2))) # final clause is an unconditional else.
          (CONS If pred then (self (iadd i 2)))>>>>>

<macro when [-pred &body]
  # if 'pred', do 'exprs'. else none.
  (CONS If pred (CONS Do body) void)>

<macro check [-condition -msg]
  ~<do <if (not ,condition) (error ,msg)> void>> # void foils TCO so that trace reveals test.

<macro or [&exprs]
  <let len (alen exprs)>
  <recur [-i=0]
    <if (ieq i len) false
      (CONS If (ael exprs i) true (self (iinc i)))>>>

<macro and [&exprs]
  <let len (alen exprs)>
  <recur [-i=0]
    <if (ieq i len) true
      (CONS If (ael exprs i) (self (iinc i)) false)>>>

# output functions.

<let-fn write1 [-file -str]
  # write a single string.
  # TODO: support other types.
  (write (.ptr file) str)>

<let-fn writeR1 [-file -obj]
  # write a single repr.
  (write-repr (.ptr file) obj)>

<macro pub-writer [-name -writer1 -file -sep -end]
  ~<pub-fn ,name [&items]
    <recur [-i=0]
      <if (ieq i (alen items))
        (write1 ,file ,end)
        <do
          <if i (write1 ,file ,sep)>
          (,writer1 ,file (ael items i))
          (self (iinc i))>>>>>

<pub-writer out   write1 std-out '' ''>
<pub-writer outS  write1 std-out ' ' ''>
<pub-writer outSS write1 std-out ' ' ' '>
<pub-writer outL  write1 std-out '' '\n'>
<pub-writer outSL write1 std-out ' ' '\n'>
<pub-writer outLL write1 std-out '\n' '\n'>

<pub-writer err   write1 std-err '' ''>
<pub-writer errS  write1 std-err ' ' ''>
<pub-writer errSS write1 std-err ' ' ' '>
<pub-writer errL  write1 std-err '' '\n'>
<pub-writer errSL write1 std-err ' ' '\n'>
<pub-writer errLL write1 std-err '\n' '\n'>

<pub-writer outR   writeR1 std-out '' ''>
<pub-writer outRS  writeR1 std-out ' ' ''>
<pub-writer outRSS writeR1 std-out ' ' ' '>
<pub-writer outRL  writeR1 std-out '' '\n'>
<pub-writer outRSL writeR1 std-out ' ' '\n'>
<pub-writer outRLL writeR1 std-out '\n' '\n'>

<pub-writer errR   writeR1 std-err '' ''>
<pub-writer errRS  writeR1 std-err ' ' ''>
<pub-writer errRSS writeR1 std-err ' ' ' '>
<pub-writer errRL  writeR1 std-err '' '\n'>
<pub-writer errRSL writeR1 std-err ' ' '\n'>
<pub-writer errRLL writeR1 std-err '\n' '\n'>

# type bootstrapping.

<macro let-type [-name -kind]
  # type instances are structs of -name:Expr -kind:Type-kind.
  # note that the type of name is Expr, not Sym,
  # because the name of a derived type might be the expression used to derive it.
  # Type-kind is a union of the various Type-kind-*.
  ~<let ,name (CONS Type `,name ,kind)>>

# idiomatic type vars.
<let-type T (CONS Type-kind-var `T)>
<let-type K (CONS Type-kind-var `K)>
<let-type V (CONS Type-kind-var `V)>

# comparison.

<pub-fn iso [-a -b]
  <if (is a b) true
    (not (is (type-of a) (type-of b))) false
    (not (is-ref a)) false
    (is-data a) (data-ref-iso a b)
    (is-env a) false # environments have identity equality.
    <do
      <let len (cmpd-len a)>
      <if (ine len (cmpd-len b)) false
        (not len) true
        <do
          <let last (idec len)>
          <recur [-i=0]
            <let ai (cmpd-field a i)>
            <let bi (cmpd-field b i)>
            <if (ieq i last) (iso ai bi) # tail optimized.
              (not (iso ai bi)) false
              (self (iinc i))>>>>>>>

# unit tests.

<macro utest [-expectation &body]
  ~<scope
    <let exp ,expectation>
    <let act <scope ,*body>>
    <when (not (iso exp act))
      (outRSL 'expect:' exp)
      (outRSL 'actual:' act)
      (error "utest failure.")>>>

# Arr.

<let-type Arr (CONS Type-kind-arr T)>

<let-type Arr-Int (CONS Type-kind-arr Int)>

<let-fn arr-copy-to [-dst:Arr -src:Arr -to:Int]
  <check (ige (alen dst) to) "dst is smaller than end index 'to'">
  <check (ige (alen src) to) "src is smaller than end index 'to'">
  <recur [-i=0]
    <if (ieq i to) dst
      <do
        (aput dst i (ael src i))
        (self (iinc i))>>>>

<let-fn arr-copy [-dst:Arr -src:Arr] (arr-copy-to dst src (alen src))>

<let-fn arr-clone [-arr:Arr] (arr-copy (anew (alen src)) src)>

<let-fn arr-resize [-arr:Arr -len:len]
  # create a new array with elements copied from arr; further elements remain UNINIT.
  (arr-copy-to (anew Arr len) arr (alen arr))>

<let-fn arr-map [-arr -ret-type:Type -f]
  <let l (alen arr)>
  <let res (anew ret-type l)>
  <recur [-i=0]
    <if (ieq i l) res
      <do
        (aput res i (f (ael arr i)))
        (self (iinc i))>>>>

# type declarations.

<macro let-struct [-name &fields]
  <let pars (arr-map fields Arr-Par <fn [-field]
    (CONS Par (.name field) (.type field) (.expr field))>)>
  ~<let-type ,name (CONS Type-kind-struct
      `,pars
      nil)>> # dispatcher

<macro let-union [-name &variants]
  ~<let-type ,name (CONS Type-kind-struct `,(arr-map variants Arr-Type identity))>>

# List (untyped).

<let-struct List -len:Int -arr:Arr> # resizable array.

<let-fn list-el [-list:List -index:Int]
  <check (ilt index (.len list)) "index out of bounds">
  (ael (.arr list) index)>

<let-fn list-put [-list:list -index:Int -el:T]
  check((ilt index (.len list)) "index out of bounds")
  (aput (.arr list) index el)>

<let-fn list-is-full [-list:List] (ieq (.len list) (alen (.arr list)))>

<let-fn list-grow [-list:List]
  <check (list-is-full list) "list should not grow unless arr is full">
  <let len (.len list)>
  <let cap <if len (imul len 2) 2>>
  (.=arr list (arr-resize (.arr list) cap))>

<let-fn list-append [-list:List -el:T]
  <if (list-is-full list) (list-grow list)>
  <let index (.len list)>
  (.=len list (iinc index))
  (aput (.arr list) index el)>

<let-fn list-contains [-list:List -el:T]
  <recur [-i=0]
    <if (ieq i (.len list)) false
      (iso el (list-el list i)) true
      (self (iinc i))>>>

<let-fn list-new [&els]
  <let l (CONS List 0 (CONS Arr))>
  <recur [-i=0]
    <if (ieq i (alen els)) l
      <do
        (list-append l (ael els i))
        (self (iinc i))>>>>

# List as Set.

<let-fn list-set-put [-set:List -el:T]
  <if (not (list-contains set el))
    (list-append set el)>>

# List as Dict.

<let-struct Dict-item -key:K -val:V>

<let-fn list-dict-contains [-dict:List -key:K]
  <recur [-i=0]
    <if (ieq i (.len dict)) false
      <do
        <let e (list-el dict i)>
        <if (iso (.key e) key) true
          (self (iinc i))>>>>>

<let-fn list-dict-fetch [-dict:List -key:K]
  <recur [-i=0]
    <if (ieq i (.len dict)) nil # signal missing key with nil.
      <do
        <let e (list-el dict i)>
        <if (iso (.key e) key) (.val e)
          (self (iinc i))>>>>>

<let-fn list-dict-put [-dict:List -key:K -val:V]
  <recur [-i=0]
    <if (ieq i (.len dict)) (list-append dict (CONS Dict-item key val))
      <do
        <let e (list-el dict i)>
        <if (iso (.key e) key) (.=val e val)
          (self (iinc i))>>>>>

<let-fn list-dict-new [&kv]
  <check (not (imod (alen kv) 2)) "dangling key">
  <let d (list-new)>
  <recur [-i=0]
    <if (ieq i (alen kv)) d
      <do
        (list-dict-put d (ael kv i) (ael kv (iinc i)))
        (self (iadd i 2))>>>>

# type derivation.

<let-struct Type-derivation-key -type:Type -dict:Dict>

<let derived-type-memo (list-new)>

<let-fn derive-type [-type:Type -dict:Dict]
  # NOTE: dict entries must be in some canonical order or else memo fetch will fail.
  <let k (.kind type)>
  <let tk (type-of k)>
  <if (is tk Type-kind-var)
    <if (list-dict-contains dict type) (list-dict-fetch dict type) type>
    <do
      <let memo-key (CONS Type-derivation-key type dict)>
      <let memoized (list-dict-fetch derived-type-memo memo-key)>
      <if (not (is memoized nil)) memoized
        <do
          <let res <if
            (is tk Type-kind-arr)
            <do
              <let orig (.el-type k)>
              <let derived (derive-type orig dict)>
              <if (is derived orig) type (CONS Type `DERIVED-ARR (CONS Type-kind-arr derived))>>
            (is tk Type-kind-struct)
            <recur [-i=0 -t=type]
              <let kind (.kind t)>
              <let fields (.fields kind)>
              <let field (ael fields i)>
              <let orig (.type field)>
              <let derived (derive-type orig dict)>
              <if (is derived orig) (self (iinc i) t) # no change to result t.
                <do
                  <let field-derived (CONS Par (.name field) derived (.dflt))>
                  (self
                    (iinc i)
                    <if (is t type) # identical thus far; clone and alter.
                      (CONS Type `DERIVED-STRUCT (CONS Type-kind-struct
                        (aput (arr-clone fields) i field-derived)
                        (.dispatcher type)))
                      <do # already cloned.
                        (aput fields i field-derived)
                        t>>)>>>
            (is tk Type-kind-union)
            <recur [-i=0 -t=type]
              <let kind (.kind t)>
              <let variants (.variants kind)>
              <let orig (ael variants i)>
              <let derived (derive-type orig dict)>
              (self
                (iinc i)
                <if (is derived orig) t # no change to result t.
                  (is t type) # identical thus far; clone and alter.
                  (CONS Type `DERIVED-UNION (CONS Type-kind-union
                    (aput (arr-clone variants) i derived)))
                    (aput i t derived)>)>
          type>> # default case returns type unaltered.
        (list-dict-put derived-type-memo memo-key res)
        res>>>>>
