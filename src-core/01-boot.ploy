# Copyright 2014 George King.
# Permission to use this file is granted in ploy/license.txt.

# bootstrap ploy, beginning with macros for the special forms.
# this module defines initial versions of many core constructs;
# some are imported into core, and others are replaced with more capable implementations.

(RUN # special call form to run the argument as code in the current environment.
  # the 'macro' macro defines a new macro in the current environment.
  # because we cannot use macro to define itself, we must define it using raw forms.
  # note the structural similarity between the outer Fn form and the inner struct literal.
  (CONS Bind
    true # is-public.
    `macro # name.
    (CONS Fn # Fn creates both functions and macros.
      true # is-native.
      true # is-macro.
      `[-sym -pars &body] # the parameter list, which does not get evaluated.
      `(CONS Bind # the body of the 'macro' macro is a Bind form.
        true # is-public.
        sym # name.
        (CONS Fn # the value of the binding is created by evaluating the Fn form.
          true # is-native.
          true # is-macro.
          pars
          (CONS Do body))))))

# define macros to wrap the special forms.

<macro fn [-pars &body]
  # create a function.
  (CONS Fn
    true # is-native.
    false # is-macro.
    pars
    (CONS Do body))>

<macro do [&body]
  (CONS Do body)>

<macro scope [&body]
  (CONS Scope (CONS Do body))>

<macro let [-sym -expr]
  # private binding.
  (CONS Bind false sym expr)>

<macro pub [-sym -expr]
  # public binding.
  (CONS Bind true sym expr)>

# the raw forms are now available through macros.

<macro let-fn [-sym -pars &body]
  ~<let ,sym <fn ,pars <let ,sym self> ,*body>>>

<macro pub-fn [-sym -pars &body]
  ~<pub ,sym <fn ,pars <let ,sym self> ,*body>>>

<let alen cmpd-len> # for now use a simple alias.

# math functions.

<pub-fn iinc [-i] (iadd i 1)>

<pub-fn idec [-i] (isub i 1)>

# control flow.

<pub-fn error [-msg]
  # raise an error. for now we can only print the message and exit.
  (raise msg)>

<macro recur [-pars &body]
  ~(<fn ,pars ,*body>)>

<macro _if [-pred -then -else]
  # bootstrap 'if' that takes exactly three expressions.
  (CONS If pred then else)>

<macro if [&exprs]
  # generic 'if'. inspired by paul graham's arc-lisp.
  <let len (alen exprs)>
  <_if (ilt len 2) (error "degenerate if form")
    <recur [-i=0]
      <let pred (ael exprs i)>
      <let then (ael exprs (iinc i))>
      <_if (ieq (iadd i 2) len)
        (CONS If pred then void) # final if-else.
        <_if (ieq (iadd i 3) len)
          (CONS If pred then (ael exprs (iadd i 2))) # final clause is an unconditional else.
          (CONS If pred then (self (iadd i 2)))>>>>>

<macro when [-pred &body]
  # if 'pred', do 'exprs'. else none.
  (CONS If pred (CONS Do body) void)>

<macro check [-condition -msg]
  ~<do <if (not ,condition) (error ,msg)> void>> # void foils TCO so that trace reveals test.

<macro or [&exprs]
  <let len (alen exprs)>
  <recur [-i=0]
    <if (ieq i len) false
      (CONS If (ael exprs i) true (self (iinc i)))>>>

<macro and [&exprs]
  <let len (alen exprs)>
  <recur [-i=0]
    <if (ieq i len) true
      (CONS If (ael exprs i) (self (iinc i)) false)>>>

# type functions.

<pub-fn is-ptr    [-o] (is (type-of o) Ptr)>
<pub-fn is-int    [-o] (is (type-of o) Int)>
<pub-fn is-sym    [-o] (is (type-of o) Sym)>
<pub-fn is-data   [-o] (is (type-of o) Data)>
<pub-fn is-env    [-o] (is (type-of o) Env)>
<pub-fn is-type   [-o] (is (type-of o) Type)>
<pub-fn is-label  [-o] (is (type-of o) Label)>
<pub-fn is-variad [-o] (is (type-of o) Variad)>

<pub-fn is-arr    [-o] (is (type-of (.kind (type-of o))) Type-kind-arr)>
<pub-fn is-struct [-o] (is (type-of (.kind (type-of o))) Type-kind-struct)>

<pub-fn is-cmpd [-o] <or (is-arr o) (is-struct o)>>

<pub-fn is-type-conforming [-act:Type -req:Type]
  # TODO!
  true>

# output functions.

<let-fn write1 [-file -str]
  # write a single string.
  # TODO: support other types.
  (write (.ptr file) str)>

<let-fn writeR1 [-file -obj]
  # write a single repr.
  (write-repr (.ptr file) obj)>

<macro pub-writer [-name -writer1 -file -sep -end]
  ~<pub-fn ,name [&items]
    <recur [-i=0]
      <if (ieq i (alen items))
        (write1 ,file ,end)
        <do
          <if i (write1 ,file ,sep)>
          (,writer1 ,file (ael items i))
          (self (iinc i))>>>>>

<pub-writer out   write1 std-out '' ''>
<pub-writer outS  write1 std-out ' ' ''>
<pub-writer outSS write1 std-out ' ' ' '>
<pub-writer outL  write1 std-out '' '\n'>
<pub-writer outSL write1 std-out ' ' '\n'>
<pub-writer outLL write1 std-out '\n' '\n'>

<pub-writer err   write1 std-err '' ''>
<pub-writer errS  write1 std-err ' ' ''>
<pub-writer errSS write1 std-err ' ' ' '>
<pub-writer errL  write1 std-err '' '\n'>
<pub-writer errSL write1 std-err ' ' '\n'>
<pub-writer errLL write1 std-err '\n' '\n'>

<pub-writer outR   writeR1 std-out '' ''>
<pub-writer outRS  writeR1 std-out ' ' ''>
<pub-writer outRSS writeR1 std-out ' ' ' '>
<pub-writer outRL  writeR1 std-out '' '\n'>
<pub-writer outRSL writeR1 std-out ' ' '\n'>
<pub-writer outRLL writeR1 std-out '\n' '\n'>

<pub-writer errR   writeR1 std-err '' ''>
<pub-writer errRS  writeR1 std-err ' ' ''>
<pub-writer errRSS writeR1 std-err ' ' ' '>
<pub-writer errRL  writeR1 std-err '' '\n'>
<pub-writer errRSL writeR1 std-err ' ' '\n'>
<pub-writer errRLL writeR1 std-err '\n' '\n'>

# comparison.

<pub-fn isnt [-a -b] (not (is a b))>

<pub-fn iso [-a -b]
  <if (is a b) true
    (isnt (type-of a) (type-of b)) false
    (not (is-ref a)) false
    (is-data a) (data-ref-iso a b)
    (is-env a) false # environments have identity equality.
    <do
      <let len (cmpd-len a)>
      <if (ine len (cmpd-len b)) false
        (not len) true
        <do
          <let last (idec len)>
          <recur [-i=0]
            <let ai (cmpd-el a i)>
            <let bi (cmpd-el b i)>
            <if (ieq i last) (iso ai bi) # tail optimized.
              (not (iso ai bi)) false
              (self (iinc i))>>>>>>>

<pub-fn not-iso [-a -b] (not (iso a b))>

# const.

<pub-fn const [-val] <fn [] val>>

<pub-fn const1 [-val] <fn [-a] val>>

<pub-fn const2 [-val] <fn [-a -b] val>>

# unit tests.

<macro utest [-expectation &body]
  ~<scope
    <let exp ,expectation>
    <let act <scope ,*body>>
    <when (not-iso exp act)
      (errRSL 'expect:' exp)
      (errRSL 'actual:' act)
      (error "utest failure.")>>>

# cmpd.

<let-fn cmpd-clone [-obj] (CONS (type-of obj) *obj)>

# Arr.

<let-fn arr-clone [-arr:Arr-Obj -len:Int=(alen arr)] (CONS (type-of arr) *arr)>

<let-fn arr-copy-to [-dst:Arr-Obj -src:Arr-Obj -to:Int]
  <check (ige (alen dst) to) "dst is smaller than end index 'to'">
  <check (ige (alen src) to) "src is smaller than end index 'to'">
  <recur [-i=0]
    <if (ieq i to) dst
      <do
        (aput dst i (ael src i))
        (self (iinc i))>>>>

<let-fn arr-copy [-dst:Arr-Obj -src:Arr-Obj] (arr-copy-to dst src (alen src))>

# TODO: copy-deep, clone-deep?

<let-fn arr-resize [-arr:Arr-Obj -len:Int]
  # create a new array with elements copied from arr; further elements remain UNINIT.
  (arr-copy-to (anew Arr-Obj len) arr (alen arr))>

<let-fn arr-map [-arr -ret-type:Type -f]
  <let l (alen arr)>
  <let res (anew ret-type l)>
  <recur [-i=0]
    <if (ieq i l) res
      <do
        (aput res i (f (ael arr i)))
        (self (iinc i))>>>>

# type definitions.

<macro let-type [-name -kind]
  # type instances are structs of -name:Expr -kind:Type-kind.
  # note that the type of name is Expr, not Sym,
  # because the name of a derived type might be the expression used to derive it.
  # Type-kind is a union of the various Type-kind-*.
  ~<let ,name (CONS Type `,name ,kind)>>

<macro let-type-var [-name] ~<let-type ,name (CONS Type-kind-var)>>

# idiomatic type vars.
<let-type-var T>
<let-type-var K>
<let-type-var V>

<macro let-struct [-name &fields]
  <let pars (arr-map fields Arr-Par <fn [-field]
    (CONS Par (.name field) (.type field) (.expr field))>)>
  ~<let-type ,name (CONS Type-kind-struct
      `,pars
      nil)>> # dispatcher

<macro let-union [-name &variants]
  ~<let-type ,name (CONS Type-kind-struct `,(arr-map variants Arr-Type identity))>>

# List (untyped).

<let-struct List -len:Int -arr:Arr-Obj> # resizable array.

<let-fn list-el [-list:List -index:Int]
  <check (ilt index (.len list)) "index out of bounds">
  (ael (.arr list) index)>

<let-fn list-put [-list:List -index:Int -el:Obj]
  check((ilt index (.len list)) "index out of bounds")
  (aput (.arr list) index el)>

<let-fn list-is-full [-list:List] (ieq (.len list) (alen (.arr list)))>

<let-fn list-grow [-list:List]
  <check (list-is-full list) "list should not grow unless arr is full">
  <let len (.len list)>
  <let cap <if len (imul len 2) 2>>
  (.=arr list (arr-resize (.arr list) cap))
  list>

<let-fn list-append [-list:List -el:Obj]
  <if (list-is-full list) (list-grow list)>
  <let index (.len list)>
  (.=len list (iinc index))
  (aput (.arr list) index el)
  list>

<let-fn list-contains [-cmp:Func -list:List -el:Obj]
  <recur [-i=0]
    <if (ieq i (.len list)) false
      (cmp el (list-el list i)) true
      (self (iinc i))>>>

<let-fn list-new [&els]
  <let l (CONS List 0 (CONS Arr-Obj))>
  <recur [-i=0]
    <if (ieq i (alen els)) l
      <do
        (list-append l (ael els i))
        (self (iinc i))>>>>

# List as Set.

<let-fn list-set-put [-cmp:Func -set:List -el:Obj]
  # returns false if set already contains the element.
  <recur [-i=0]
    <if (ieq i (.len set)) <do (list-append set el) true>
      (cmp el (list-el set i)) false
      (self (iinc i))>>>

# List as Dict.

<let-struct Dict-item -key:Obj -val:Obj>
<let-struct Dict-fetch -found:Bool -val:Obj>

<let-fn list-dict-contains [-cmp:Func -dict:List -key:Obj]
  <recur [-i=0]
    <if (ieq i (.len dict)) false
      <do
        <let e (list-el dict i)>
        <if (cmp (.key e) key) true
          (self (iinc i))>>>>>

<let-fn list-dict-fetch [-cmp:Func -dict:List -key:Obj]
  <recur [-i=0]
    <if (ieq i (.len dict)) (CONS Dict-fetch false nil)
      <do
        <let e (list-el dict i)>
        <if (cmp (.key e) key) (CONS Dict-fetch true (.val e))
          (self (iinc i))>>>>>

<let-fn list-dict-put [-cmp:Func -cmp-val:Func -dict:List -key:Obj -val:Obj]
  # returns false if dict already contains the item;
  # raises an error if dict contains the key, but value does not match.
  <recur [-i=0]
    <if (ieq i (.len dict))
      <do (list-append dict (CONS Dict-item key val)) true>
      <do
        <let e (list-el dict i)>
        <if (cmp (.key e) key)
          <do
            <check (cmp-val (.val e) val)
              "list-dict-put: different value already exists for key">
            false>
          (self (iinc i))>>>>>

<let-fn list-dict-new [&kv]
  <check (not (imod (alen kv) 2)) "dangling key">
  <let d (list-new)>
  <recur [-i=0]
    <if (ieq i (alen kv)) d
      <do
        (list-dict-put is is d (ael kv i) (ael kv (iinc i)))
        (self (iadd i 2))>>>>

# generics.

<macro generic [-name -expr]
  ~<let ,name `,expr>>

<let-struct Gnr-deriv-key -type:Obj -dict:List>

<let gnr-memo (list-new)>

<let-fn derive [-expr:Expr -dict:List]
  # NOTE: dict entries must be in some canonical order or else memo fetch will fail.

  <if (is-sym expr)
    <do
      <let item (list-dict-fetch is dict expr)>
      <if (.found item) (.val item) expr>>
    <do
      <if (not (is-cmpd expr))
        expr
        <do
          <let-fn derive-cmpd []
            # derive an instance from expr; the result will be checked against the memo cache.
            <let len (cmpd-len expr)>
            <let start <if (is-label expr) 1 0>> # special case for label names.
            <recur [-i=start -res=expr]
              <if (ieq i len) res
                <do
                  <let sub (cmpd-el expr i)>
                  <let sub-derived (derive sub dict)>
                  (self (iinc i)
                    <if (is sub-derived sub) res # no change.
                      (cmpd-put <if (is res expr) (cmpd-clone expr) res> i sub-derived)>)>>>>
          (derive-cmpd)>>>>>

<generic Arr (CONS Type `(Arr -E:E) (CONS Type-kind-arr E))>

#<let Arr-Int (RUN (derive Arr (list-dict-new `E `Int)))>
