# Copyright 2014 George King.
# Permission to use this file is granted in ploy/license.txt.

# bootstrap ploy, beginning with macros for the special forms.
# this module defines initial versions of many core constructs;
# some are imported into core, and others are replaced with more capable implementations.

(RUN # special call form to run the argument as code in the current environment.
  # the 'macro' macro defines a new macro in the current environment.
  # because we cannot use macro to define itself, we must define it using raw forms.
  # note the structural similarity between the outer Fn form and the inner struct literal.
  {:Bind
    false # is-mutable.
    true # is-public.
    `macro # name.
    {:Fn # Fn creates both functions and macros.
      true # is-native.
      true # is-macro.
      `[-sym -pars &body] # the parameter list, which does not get evaluated.
      nil # ret-type.
      `{:Bind # the body of the 'macro' macro is a Bind form.
        false # is-mutable.
        true # is-public.
        sym # name.
        {:Fn # the value of the binding is created by evaluating the Fn form.
          true # is-native.
          true # is-macro.
          pars
          nil # ret-type.
          {:Do {:Arr-Expr *body}}}}}})

# define macros to wrap the special forms.

<macro fn [-pars &body]
  # create a function.
  {:Fn
    true # is-native.
    false # is-macro.
    pars
    nil # ret-type.
    {:Do {:Arr-Expr *body}}}>

<macro quo [-expr]
  # absolute quotation of an expression.
  # evaluating a QUO form simply yields the contained expression, unevaluated.
  {:Quo expr}>

<macro qua [-expr]
  # quasiquotation of an expression.
  # this is similar to quo, except that subexpressions can be unquoted,
  # in which case they are evaluated.
  # QUA forms themselves do not evaluate; they are converted by the preprocessor.
  # equivalent to `expr syntax.
  # TODO: implement quasiquotation as a macro instead of in the preprocessor?
  {:Qua expr}>

<macro unq [-expr]
  # unquotation of an expression.
  # this form indicates that the unquoted subexpression should be evaluated within a qua form.
  # this for does not evaluate, and therefore must be inside of a qua,
  # where it will get transformed appropriately.
  # equivalent to ,expr syntax
  {:Unq expr}>

<macro do [&body]
  {:Do {:Arr-Expr *body}}>

<macro scope [&body]
  {:Scope {:Do {:Arr-Expr *body}}}>

<macro let [-sym -expr]
  # immutable, private binding.
  {:Bind false false sym expr}>

<macro var [-sym -expr]
  # mutable, private binding.
  {:Bind true false sym expr}>

<macro pub [-sym -expr]
  # immutable, public binding.
  {:Bind false true sym expr}>

# the raw forms are now available through macros.

<macro let-fn [-sym -pars &body]
  ~<let ,sym <fn ,pars ,*body>>>

<macro pub-fn [-sym -pars &body]
  ~<pub ,sym <fn ,pars ,*body>>>

<macro mk-type [-name -kind]
  # type instances are structs of -name:Expr -kind:Type-kind.
  # note that the type of name is Expr, not Sym,
  # because the name of a derived type might be the expression used to derive it.
  # Type-kind is a union of the various Type-kind-*.
  ~<let ,name {:Type `,name ,kind}>>

<mk-type Arr-Int {:Type-kind-arr Int}>

<pub-fn error [-msg]
  # raise an error. for now we can only print the message and exit.
  (_host-write (.ptr std-err) 'error: ')
  (_host-write (.ptr std-err) msg)
  (_host-write (.ptr std-err) '\n')
  (exit 1)>

<macro check [-condition -msg]
  ~<if (not ,condition) (error ,msg)>>

# math functions.

<pub-fn iinc [-i] (iadd i 1)>

<pub-fn idec [-i] (isub i 1)>

# type functions.

<pub-fn is-ptr  [-o] (is (type-of o) Ptr)>
<pub-fn is-int  [-o] (is (type-of o) Int)>
<pub-fn is-sym  [-o] (is (type-of o) Sym)>
<pub-fn is-data [-o] (is (type-of o) Data)>
<pub-fn is-env  [-o] (is (type-of o) Env)>
<pub-fn is-type [-o] (is (type-of o) Type)>

# arr functions.

<pub-fn hd [-arr] (el arr 0)>

<pub-fn tl [-arr] (el arr (idec (alen arr)))>

<pub-fn arr-next [-arr]
  # this a poor substitute for a real Stream iterator.
  (slice arr 1 (alen arr))>

<pub-fn arr-from [-arr -from]
  (slice arr from (alen arr))>

<pub-fn arr-to [-arr -to]
  (slice arr 0 to)>

# control flow.

<macro _if-then [-pred -then]
  # 'if' variant that takes exactly two expressions; for bootstrapping the 'if' macro.
  {:If pred then void}>

<macro _if-then-else [-pred -then -else]
  # 'if' variant that takes exactly three expressions; for bootstrapping the 'if' macro.
  {:If pred then else}>

<macro if [&exprs]
  # generic 'if'. inspired by paul graham's arc-lisp.
  <_if-then (ilt (alen exprs) 2) (error "degenerate if form")>
  <let-fn f [-pred -then -rest]
    <let l (alen rest)>
    #(_errR1L 'f l: ' l)
    #(_errR1L 'f pred: ' pred)
    #(_errR1L 'f then: ' then)
    #(_errR1L 'f rest: ' rest)
    <_if-then-else (not l)
      {:If pred then void} # final if-else
      <_if-then-else (ieq l 1)
        {:If pred then (hd rest)} # final clause is an unconditional else.
        {:If pred then (self (hd rest) (el rest 1) (arr-from rest 2))}>>>
  (f (hd exprs) (el exprs 1) (slice exprs 2 (alen exprs)))>

<macro when [-pred &body]
  # if 'pred', do 'exprs'. else none.
  {:If pred {:Do body} void}> # TODO: eventually this should use splice-unquote.

# output functions.

<let-fn write1 [-file -str]
  # write a single string.
  # TODO: support other types.
  (_host-write (.ptr file) str)>

<let-fn writeR1 [-file -obj]
  # write a single repr.
  (_host-write-repr (.ptr file) obj)>

# TODO: this is a temporary, halfway solution to the desired printing functions.
# would be better to use a macro to generate each function with no subcalls.

<pub-fn writeSE [-file -sep -end -first -rest]
  # write strings with separator and end strings.
  #(_errR1L 'writeSE f: ' first)
  #(_errR1L 'writeSE r: ' rest)
  (write1 file first)
  <if (not rest)
    (write1 file end)
    <do
      (write1 file sep)
      (self file sep end (hd rest) (arr-next rest))>>>

<pub-fn writeRSE [-file -sep -end -first -rest]
  # write reprs with separator and end strings.
  (writeR1 file first)
  <if (not rest)
    (write1 file end)
    <do
      (write1 file sep)
      (self file sep end (hd rest) (arr-next rest))>>>

<macro pub-writeWFSE [-name -writer -file -sep -end]
  ~<pub-fn ,name [&objs]
    <if (not objs)
      (write1 ,file ,end)
      (,writer ,file ,sep ,end (hd objs) (arr-next objs))>>>

<pub-writeWFSE out   writeSE std-out '' ''>
<pub-writeWFSE outS  writeSE std-out ' ' ''>
<pub-writeWFSE outSS writeSE std-out ' ' ' '>
<pub-writeWFSE outL  writeSE std-out '' '\n'>
<pub-writeWFSE outSL writeSE std-out ' ' '\n'>
<pub-writeWFSE outLL writeSE std-out '\n' '\n'>

<pub-writeWFSE err   writeSE std-err '' ''>
<pub-writeWFSE errS  writeSE std-err ' ' ''>
<pub-writeWFSE errSS writeSE std-err ' ' ' '>
<pub-writeWFSE errL  writeSE std-err '' '\n'>
<pub-writeWFSE errSL writeSE std-err ' ' '\n'>
<pub-writeWFSE errLL writeSE std-err '\n' '\n'>

<pub-writeWFSE outR   writeRSE std-out '' ''>
<pub-writeWFSE outRS  writeRSE std-out ' ' ''>
<pub-writeWFSE outRSS writeRSE std-out ' ' ' '>
<pub-writeWFSE outRL  writeRSE std-out '' '\n'>
<pub-writeWFSE outRSL writeRSE std-out ' ' '\n'>
<pub-writeWFSE outRLL writeRSE std-out '\n' '\n'>

<pub-writeWFSE errR   writeRSE std-err '' ''>
<pub-writeWFSE errRS  writeRSE std-err ' ' ''>
<pub-writeWFSE errRSS writeRSE std-err ' ' ' '>
<pub-writeWFSE errRL  writeRSE std-err '' '\n'>
<pub-writeWFSE errRSL writeRSE std-err ' ' '\n'>
<pub-writeWFSE errRLL writeRSE std-err '\n' '\n'>
