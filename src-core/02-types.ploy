# Copyright 2014 George King.
# Permission to use this file is granted in ploy/license.txt.

# ploy type system.

<macro mk-type [-name -kind]
  # type instances are structs of -name:Expr -kind:Type-kind.
  # note that the type of name is Expr, not Sym,
  # because the name of a derived type might be the expression used to derive it.
  # Type-kind is a union of the various Type-kind-*.
  ~<let ,name {:Type `,name ,kind}>>

<fn init-kind [-type -kind]
  (init-el type 1 kind)>

<mk-type Type-kind-unit
  # unit types have a unique singleton instance, and therefore the kind contains no information.
  # thus, the Type-kind of Type-kind-unit is Type-kind-unit.
  `UNINIT> # circular reference.
<let type-kind-unit {:Type-kind-unit}> # create the singleton instance manually.
(init-kind Type-kind-unit type-kind-unit) # Type-kind-unit is now well-formed.

<mk-type Type-kind-prim
  # the primitive types are opaque from the perspective of the type system;
  # therefore Type-kind-prim is also a unit type.
  type-kind-unit>
<let type-kind-prim {:Type-kind-prim}> # create the singleton instance manually.

<mk-type Type-kind-mem `UNINIT>
<mk-type Type-kind-struct `UNINIT>
<mk-type Type-kind-union `UNINIT>

<mk-type Type-kind-class
  # type classes are abstract, synonymous with interfaces.
  # not yet implemented, so for now define as a unit type.
  type-kind-unit>
<let type-kind-class {:Type-kind-class}>

<mk-type Type-kind-var
  # type variables are placeholders, used for type parameterization.
  # they are 'abstract' in the sense that no instance ever has such a type.
  type-kind-unit>
<let type-kind-var {:Type-kind-var}>

<mk-type Mem-Type {:Type-kind-mem Type}>

(init-kind Type-kind-mem
  # mem types are dynamic-length blocks of a single element type;
  # the type-kind is a struct of one field specifying the element type.
  {:Type-kind-struct
    {:Mem-Par # -fields
      {:Par `el-type Type `void}}})

(init-kind Type-kind-struct
  # struct types are defined by a list of field names/type pairs.
  # the type-kind is a struct of one field, 'fields'.
  {:Type-kind-struct
    {:Mem-Par # -fields
      {:Par `fields Mem-Par `void}}})

(init-kind Type-kind-union
  # union types are defined by a list of variant types.
  # the type-kind is a struct of one field, 'variants'.
  {:Type-kind-struct
    {:Mem-Par # -fields
      {:Par `variants Mem-Type `void}}})

<mk-type Type-kind
  {:Type-kind-union
    {:Mem-Type # -variants
      Type-kind-unit
      Type-kind-prim
      Type-kind-mem
      Type-kind-struct
      Type-kind-union
      Type-kind-class
      Type-kind-var}}>

<mk-type Bool type-kind-prim>
<mk-type Obj type-kind-class>

# now that the metatypes have been defined, we can finish defining the builtin types.

(init-kind Type
  {:Type-kind-struct
    {:Mem-Par # -fields
      {:Par `name Expr `void}
      {:Par `kind Type-kind `void}}})

(init-kind Ptr type-kind-prim)
(init-kind Int type-kind-prim)
(init-kind Sym type-kind-prim)
(init-kind Data type-kind-prim)
(init-kind Env type-kind-prim)

<fn init-kind-struct1 [-type -field-name -field-type]
  (init-kind type {:Type-kind-struct {:Mem-Par {:Par field-name field-type `void}}})>

<fn init-kind-struct2 [-type -field-name0 -field-type0 -field-name1 -field-type1]
  (init-kind type {:Type-kind-struct {:Mem-Par
    {:Par field-name0 field-type0 `void}
    {:Par field-name1 field-type1 `void}}})>

<fn init-kind-struct3
  [-type -field-name0 -field-type0 -field-name1 -field-type1 -field-name2 -field-type2]
  (init-kind type {:Type-kind-struct {:Mem-Par
    {:Par field-name0 field-type0 `void}
    {:Par field-name1 field-type1 `void}
    {:Par field-name2 field-type2 `void}}})>

(init-kind-struct3 Par `name Sym `type Type `dflt Expr)

(init-kind-struct1 Unq `expr Expr)
(init-kind-struct1 Qua `expr Expr)
(init-kind-struct1 Quo `expr Expr)
(init-kind-struct1 Eval `expr Expr)

# TODO: should these be type aliases of Mem-Expr?
(init-kind Expand nil)
(init-kind Do nil)
(init-kind Syn-struct-typed nil)
(init-kind Syn-seq-typed nil)
(init-kind Call nil)
(init-kind Syn-struct nil)
(init-kind Syn-seq nil)

(init-kind-struct2 Comment `is-expr-comment Bool `expr Expr)

(init-kind-struct1 Scope `expr Expr)

(init-kind-struct3 Bind `is-mutable Bool `name Sym `expr Expr)
(init-kind-struct3 If `pred Expr `then Expr `else Expr)

(init-kind-struct3 Label `name Sym `type Type `expr Expr)
(init-kind-struct2 Variad `expr Expr `type Type)

(init-kind Fn {:Type-kind-struct {:Mem-Par
  {:Par `name Sym `void}
  {:Par `is-native Bool `void}
  {:Par `is-macro Bool `void}
  {:Par `pars Syn-seq `void}
  {:Par `ret-type Type `void}
  {:Par `body Expr `void}}})

(init-kind Func {:Type-kind-struct {:Mem-Par
  {:Par `name Sym `void}
  {:Par `is-native Bool `void}
  {:Par `is-macro Bool `void}
  {:Par `env Env `void}
  {:Par `pars Mem-Par `void}
  {:Par `ret-type Type `void}
  {:Par `body Expr `void}}})

(init-kind Expr
  {:Type-kind-union
    {:Mem-Type # -variants.
      Int
      Sym
      Data
      Eval
      Quo
      Do
      Scope
      Bind
      If
      Fn
      Syn-struct-typed
      Syn-seq-typed
      Call
      Expand}})

(init-kind Mem-Obj {:Type-kind-mem Obj})
(init-kind Mem-Par {:Type-kind-mem Obj})
(init-kind Mem-Expr {:Type-kind-mem Obj})

(init-kind File nil)
(init-kind-struct2 Src `path Data `src Data)

# builtin types complete. now define additional core types.

<mk-type Mem-Int {:Type-kind-mem Int}>
