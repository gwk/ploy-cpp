# Copyright 2014 George King.
# Permission to use this file is granted in ploy/license.txt.

# core macros and functions loaded before library or user code.
# the struct syntax {...} is used to construct special form code vectors directly,
# before the idiomatic macros are defined.
# once available, the macros should be used instead of the raw forms,
# as they provide a layer of abstraction between code and the exact evaluation semantics,
# as well as increased expressiveness and syntactic consistency.


{LET _errR1L
  # print a representation of a single object to std-err.
  # defined early for debugging.
  {FN
    _errR1L # the name sym of this fn.
    false # not a macro.
    {-label -obj} # parameter list.
    {DO # body.
      # standard files are defined as a [name, file] vec.
      (raw-write (el std-err 1) label)
      (raw-write-repr (el std-err 1) obj)
      (raw-write (el std-err 1) '\n')}}}

{LET macro
  # the 'macro' macro defines a new macro in the current environment.
  # TODO: refine environment semantics?
  # note: if core was already available, we would define 'macro' using itself like so:
  ##<macro macro {-sym -pars &body}
      <let sym
        [ FN # this form creates a new function/macro that...
          sym # contains its name sym,
          true # is a macro,
          pars # has the specified parameter list,
          <if (ieq (len body) 1) # and body...
            (el body 0)
            (prepend DO body)>]>> # wrapped in a do form if necessary.
  # instead, we must define it using raw forms.
  # note the structural similarity between the outer FN form and the inner vec literal.
  {FN # creates both functions and macros
    macro # the sym for this macro is `macro;
    # we do not quote it because this is a raw form, so it is not evaluated.
    true # is-macro
    {-sym -pars &body} # the parameter list; also unquoted, as parameter lists always are.
    [LET # the body of the 'macro' macro is a LET form.
      sym # the sym parameter that the macro to be created is bound to (not `macro).
      [FN # the value of the binding is created by evaluating the FN form;
        # note that this inner FN is inside a vec literal;
        # when the 'macro' macro is expanded, the literal is evaluated,
        # and a {FN ...} form is the resulting code vector.
        sym
        true
        pars
        {IF (ieq (len body) 1)
          (el body 0)
          (prepend DO body)}]]}}

<macro fn {-sym -pars &body}
  # defines a function in the current environment.
  # TODO: refine environment semantics?
  # this is conceptually the same as macro; see the explanation above.
  [LET sym
    [ FN
      sym
      false
      pars
      {IF (ieq (len body) 1)
        (el body 0)
        (prepend DO body)}]]>

# define macros to wrap the special forms.

<macro quo {-expr}
  # absolute quotation of an expression.
  # evaluating a QUO form simply yields the contained expression, unevaluated.
  [QUO expr]>

<macro qua {-expr}
  # quasiquotation of an expression.
  # this is similar to quo, except that subexpressions can be unquoted,
  # in which case they are evaluated.
  # QUA forms themselves do not evaluate; they are converted by the preprocessor.
  # equivalent to `expr syntax.
  # TODO: implement quasiquotation as a macro instead of in the preprocessor?
  [QUA expr]>

<macro unq {-expr}
  # unquotation of an expression.
  # this form indicates that the unquoted subexpression should be evaluated within a qua form.
  # this for does not evaluate, and therefore must be inside of a qua,
  # where it will get transformed appropriately.
  # equivalent to ,expr syntax
  [UNQ expr]>

<macro do {&exprs}
  (prepend DO exprs)>

<macro let {-sym -expr}
  # bind the value of expr to sym in the current environment.
  [LET sym expr]>

<fn error {-msg}
  # raise an error. for now we can only print the message and exit.
  (raw-write (el std-err 1) 'error: ')
  (raw-write (el std-err 1) msg)
  (raw-write (el std-err 1) '\n')
  (exit 1)>

# math functions.

<fn iinc {-i} (iadd i 1)>

<fn idec {-i} (isub i 1)>

# type functions.

<fn is-int {-o} (sym-eq (type-sym o) `INT)>
<fn is-sym {-o} (sym-eq (type-sym o) `SYM)>
<fn is-data {-o} (sym-eq (type-sym o) `DATA)>
<fn is-vec {-o} (sym-eq (type-sym o) `VEC)>
<fn is-I32 {-o} (sym-eq (type-sym o) `I32)>
<fn is-I64 {-o} (sym-eq (type-sym o) `I64)>
<fn is-U32 {-o} (sym-eq (type-sym o) `U32)>
<fn is-U64 {-o} (sym-eq (type-sym o) `U64)>
<fn is-F32 {-o} (sym-eq (type-sym o) `F32)>
<fn is-F64 {-o} (sym-eq (type-sym o) `F64)>
<fn is-file {-o} (sym-eq (type-sym o) `FILE)>
<fn is-func_host {-o} (sym-eq (type-sym o) `FUNC_HOST)>


# vec functions.

<fn hd {-vec} (el vec 0)>

<fn tl {-vec} (el vec (idec (len vec)))>

<fn vec-next {-vec}
  # this a poor substitute for a real vec iterator.
 (slice vec 1 (len vec))>

<fn vec-from {-vec -from}
  (slice vec from (len vec))>

<fn vec-to {-vec -to}
  (slice vec 0 to)>

# control flow.

<macro _if-then {-pred -then}
  # 'if' variant that takes exactly two expressions; for bootstrapping the 'if' macro.
  [IF pred then void]>

<macro _if-then-else {-pred -then -else}
  # 'if' variant that takes exactly three expressions; for bootstrapping the 'if' macro.
  [IF pred then else]>

<macro if {&exprs}
  # generic 'if'. inspired by paul graham's arc-lisp.
  <_if-then (ilt (len exprs) 2) (error "degenerate if form")>
  <fn f {-pred -then -rest}
    <let l (len rest)>
    #(_errR1L 'f l: ' l)
    #(_errR1L 'f pred: ' pred)
    #(_errR1L 'f then: ' then)
    #(_errR1L 'f rest: ' rest)
    <_if-then-else (not l)
      [IF pred then void] # final if-else
      <_if-then-else (ieq l 1)
        [IF pred then (hd rest)] # final clause is an unconditional else.
        [IF pred then (self (hd rest) (el rest 1) (vec-from rest 2))]>>>
  (f (hd exprs) (el exprs 1) (slice exprs 2 (len exprs)))>

<macro when {-pred &exprs}
  # if 'pred', do 'exprs'. else none.
  [IF pred (prepend DO exprs) void]>

# output functions.

<fn write1 {-file -str}
  # write a single string.
  # TODO: support other types.
  (raw-write (el file 1) str)>

<fn writeR1 {-file -obj}
  # write a single repr.
  (raw-write-repr (el file 1) obj)>

# TODO: this is a temporary, halfway solution to the desired printing functions.
# would be better to use a macro to generate each function with no subcalls.

<fn writeSE {-file -sep -end -first -rest}
  # write strings with separator and end strings.
  #(_errR1L 'writeSE f: ' first)
  #(_errR1L 'writeSE r: ' rest)
  (write1 file first)
  <if (not rest)
    (write1 file end)
    <do
      (write1 file sep)
      (self file sep end (hd rest) (vec-next rest))>>>

<fn writeRSE {-file -sep -end -first -rest}
  # write reprs with separator and end strings.
  (writeR1 file first)
  <if (not rest)
    (write1 file end)
    <do
      (write1 file sep)
      (self file sep end (hd rest) (vec-next rest))>>>

<fn out {&objs}
  <if (not objs)
    void
    (writeSE std-out '' '' (hd objs) (vec-next objs))>>

<fn outS {&objs}
  <if (not objs)
    void
    (writeSE std-out ' ' '' (hd objs) (vec-next objs))>>

<fn outL {&objs}
  <if (not objs)
    (write1 std-out '\n')
    (writeSE std-out '' '\n' (hd objs) (vec-next objs))>>

<fn outSL {&objs}
  <if (not objs)
    (write1 std-out '\n')
    (writeSE std-out ' ' '\n' (hd objs) (vec-next objs))>>

<fn outSS {&objs}
  <if (not objs)
    (write1 std-out ' ')
    (writeSE std-out ' ' ' ' (hd objs) (vec-next objs))>>

<fn outLL {&objs}
  <if (not objs)
    (write1 std-out '\n')
    (writeSE std-out '\n' '\n' (hd objs) (vec-next objs))>>


<fn err {&objs}
  <if (not objs)
    void
    (writeSE std-err '' '' (hd objs) (vec-next objs))>>

<fn errS {&objs}
  <if (not objs)
    void
    (writeSE std-err ' ' '' (hd objs) (vec-next objs))>>

<fn errL {&objs}
  <if (not objs)
    (write1 std-err '\n')
    (writeSE std-err '' '\n' (hd objs) (vec-next objs))>>

<fn errSS {&objs}
  <if (not objs)
    (write1 std-err ' ')
    (writeSE std-err ' ' ' ' (hd objs) (vec-next objs))>>

<fn errSL {&objs}
  <if (not objs)
    (write1 std-err '\n')
    (writeSE std-err ' ' '\n' (hd objs) (vec-next objs))>>

<fn errLL {&objs}
  <if (not objs)
    (write1 std-err '\n')
    (writeSE std-err '\n' '\n' (hd objs) (vec-next objs))>>


<fn outR {&objs}
  <if (not objs)
    void
    (writeSE std-out '' '' (hd objs) (vec-next objs))>>

<fn outRS {&objs}
  <if (not objs)
    void
    (writeSE std-out ' ' '' (hd objs) (vec-next objs))>>

<fn outRL {&objs}
  <if (not objs)
    (write1 std-out '\n')
    (writeRSE std-out '' '\n' (hd objs) (vec-next objs))>>

<fn outRSS {&objs}
  <if (not objs)
    (write1 std-out ' ')
    (writeRSE std-out ' ' ' ' (hd objs) (vec-next objs))>>

<fn outRSL {&objs}
  <if (not objs)
    (write1 std-out '\n')
    (writeRSE std-out ' ' '\n' (hd objs) (vec-next objs))>>

<fn outRLL {&objs}
  <if (not objs)
    (write1 std-out '\n')
    (writeRSE std-out '\n' '\n' (hd objs) (vec-next objs))>>


<fn errR {&objs}
  <if (not objs)
    void
    (writeRSE std-err '' '' (hd objs) (vec-next objs))>>

<fn errRS {&objs}
  <if (not objs)
    void
    (writeRSE std-err ' ' '' (hd objs) (vec-next objs))>>

<fn errRL {&objs}
  <if (not objs)
    (write1 std-err '\n')
    (writeRSE std-err '' '\n' (hd objs) (vec-next objs))>>

<fn errRSS {&objs}
  <if (not objs)
    (write1 std-err ' ')
    (writeRSE std-err ' ' ' ' (hd objs) (vec-next objs))>>

<fn errRSL {&objs}
  <if (not objs)
    (write1 std-err '\n')
    (writeRSE std-err ' ' '\n' (hd objs) (vec-next objs))>>

<fn errRLL {&objs}
  <if (not objs)
    (write1 std-err '\n')
    (writeRSE std-err '\n' '\n' (hd objs) (vec-next objs))>>
